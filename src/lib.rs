/*!

*/
#![allow(clippy::redundant_field_names)]
use cglinalg::{
    Degrees,
    Vector3,
    Vector4,
    Matrix4x4, 
    Quaternion,
    ScalarFloat,
    InvertibleSquareMatrix,
    Unit,
};

use core::fmt;
use core::ops;


const MOVE_LEFT: u16             = 1 << 0;
const MOVE_RIGHT: u16            = 1 << 1;
const MOVE_UP: u16               = 1 << 2;
const MOVE_DOWN: u16             = 1 << 3;
const MOVE_FORWARD: u16          = 1 << 4;
const MOVE_BACKWARD: u16         = 1 << 5;
const PITCH_UP: u16              = 1 << 6;
const PITCH_DOWN: u16            = 1 << 7;
const YAW_LEFT: u16              = 1 << 8;
const YAW_RIGHT: u16             = 1 << 9;
const ROLL_CLOCKWISE: u16        = 1 << 10;
const ROLL_COUNTERCLOCKWISE: u16 = 1 << 11;
const NO_MOVEMENT: u16           = 0;


/// A simple camera movement is an elementary movement from which all of the 
/// general movements of a camera movement are composed of. This input method
/// is meant to decouple the updates to the camera's attitude from the input events
/// generated by an specific windowing system. Each simple camera movement describes
/// a camera movement from the coordinate system of the eye space.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SimpleCameraMovement {
    /// Move the camera left in eye space.
    MoveLeft,
    /// Move the camera right in eye space.
    MoveRight,
    /// Move the camera up in eye space.
    MoveUp,
    /// Move the camera down in eye space.
    MoveDown,
    /// Move the camera forward in eye space.
    MoveForward,
    /// Move the camera backwards in eye space.
    MoveBackward,
    /// Pitch the camera up in eye space.
    PitchUp,
    /// Pitch the camera down in eye space.
    PitchDown,
    /// Yaw the camera left in eye space.
    YawLeft,
    /// Yaw the camera right in eye space.
    YawRight,
    /// Roll the camera clockwise in eye space.
    RollClockwise,
    /// Roll the camera counterclockwise in eye space.
    RollCounterClockwise,
    /// Do not move the camera.
    NoMovement,
}

impl fmt::Display for SimpleCameraMovement {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(&self, f)
    }
}

/// A camera movement is a sequence of simple movements use to compute
/// a camera trajectory on each game state update.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct CameraMovement {
    total: u16,
}

impl CameraMovement {
    /// Construct a new empty camera movement.
    #[inline]
    pub const fn new() -> CameraMovement {
        CameraMovement {
            total: 0
        }
    }

    /// Include a camera movement in the compound camera movement.
    /// If the camera movement is already present in the compound camera movement,
    /// nothing changes.
    #[inline]
    fn add_movement(self, movement: SimpleCameraMovement) -> CameraMovement {
        use SimpleCameraMovement::*;
        let move_to = match movement {
            MoveLeft => MOVE_LEFT,
            MoveRight => MOVE_RIGHT,
            MoveUp => MOVE_UP,
            MoveDown => MOVE_DOWN,
            MoveForward => MOVE_FORWARD,
            MoveBackward => MOVE_BACKWARD,
            PitchUp => PITCH_UP,
            PitchDown => PITCH_DOWN,
            YawLeft => YAW_LEFT,
            YawRight => YAW_RIGHT,
            RollClockwise => ROLL_CLOCKWISE,
            RollCounterClockwise => ROLL_COUNTERCLOCKWISE,
            NoMovement => NO_MOVEMENT,
        };

        CameraMovement {
            total: self.total | move_to
        }
    }

    /// Remove camera movement if it is present in the compound camera movement.
    /// If the camera movement is not present in the compound camera movement, 
    /// nothing changes.
    #[inline]
    fn subtract_movement(self, movement: SimpleCameraMovement) -> CameraMovement {
        use SimpleCameraMovement::*;
        let move_to = match movement {
            MoveLeft => MOVE_LEFT,
            MoveRight => MOVE_RIGHT,
            MoveUp => MOVE_UP,
            MoveDown => MOVE_DOWN,
            MoveForward => MOVE_FORWARD,
            MoveBackward => MOVE_BACKWARD,
            PitchUp => PITCH_UP,
            PitchDown => PITCH_DOWN,
            YawLeft => YAW_LEFT,
            YawRight => YAW_RIGHT,
            RollClockwise => ROLL_CLOCKWISE,
            RollCounterClockwise => ROLL_COUNTERCLOCKWISE,
            NoMovement => NO_MOVEMENT,
        };

        CameraMovement {
            total: self.total ^ move_to
        } 
    }
}

impl ops::Add<SimpleCameraMovement> for CameraMovement {
    type Output = CameraMovement;

    #[inline]
    fn add(self, other: SimpleCameraMovement) -> Self::Output {
        self.add_movement(other)
    }
}

impl ops::Sub<SimpleCameraMovement> for CameraMovement {
    type Output = CameraMovement;

    #[inline]
    fn sub(self, other: SimpleCameraMovement) -> Self::Output {
        self.subtract_movement(other)
    }
}

impl ops::AddAssign<SimpleCameraMovement> for CameraMovement {
    #[inline]
    fn add_assign(&mut self, other: SimpleCameraMovement) {
        *self = self.add_movement(other)
    }
}

impl ops::SubAssign<SimpleCameraMovement> for CameraMovement {
    #[inline]
    fn sub_assign(&mut self, other: SimpleCameraMovement) {
        *self = self.subtract_movement(other)
    }
}

impl fmt::Debug for CameraMovement {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "CameraMovement [{:#X})]", self.total)
    }
}

impl fmt::Display for CameraMovement {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "CameraMovement [{:#X})]", self.total) 
    }
}


/// This type carries all the information describing the change in attitude of
/// the camera in Euclidean world space. This type is generated either by processing 
/// camera movements, or it can be sent directly to the camera. 
#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct DeltaAttitude<S> {
    /// The change in the `x`-component of the camera position in world space.
    x: S,
    /// The change in the `y`-component of the camera position in world space.
    y: S,
    /// The change in the `z`-component of the camera position in world space.
    z: S,
    /// The change in the orientation of the camera about the **negative z-axis**.
    roll: S,
    /// The change in the orientation of the camera about the **positive y-axis**.
    yaw: S,
    /// The change in the orientation of the camera about the **positive x-axis**.
    pitch: S,
}

impl<S> DeltaAttitude<S> where S: ScalarFloat {
    /// Construct a new change in attitude.
    #[inline]
    pub fn new(x: S, y: S, z: S, roll: S, yaw: S, pitch: S) -> Self {
        Self {
            x: x,
            y: y,
            z: z,
            roll: roll,
            yaw: yaw,
            pitch: pitch,
        }
    }

    /// Construct zero change in attitude.
    #[inline]
    pub fn zero() -> Self {
        Self {
            x: S::zero(),
            y: S::zero(),
            z: S::zero(),
            roll: S::zero(),
            yaw: S::zero(),
            pitch: S::zero(),
        }
    }
}

impl<S> fmt::Display for DeltaAttitude<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "DeltaAttitude [x={}, y={}, z={}, roll={}, yaw={}, pitch={}]",
            self.x, self.y, self.z, self.roll, self.yaw, self.pitch
        )
    }
}


/// A type with this trait can be used as a camera model. A camera model
/// is a process of mapping incoming light rays from the camera's view space into
/// the camera model's canonical view volume.
pub trait CameraModel {
    /// The type containing the parameters for constructing the camera model.
    type Spec;
    /// The type representing the underlying projection from view space into 
    /// normalized device coordinates.
    type Projection;

    /// Construct a camera model from a description of the 
    /// camera model's parameters.
    fn from_spec(spec: &Self::Spec) -> Self;

    /// Exposed the underlying transformation that maps vector in the camera's
    /// view space into the canonical view volume of the camera.
    fn projection(&self) -> &Self::Projection;

    /// Update the camera model based on changes in the viewport dimensions.
    fn update(&mut self, width: usize, height: usize);
}


/// A type with this trait controls how a camera moves throughout a scene in
/// Euclidean space.
pub trait CameraKinematics<S> {
    /// A description of the parameters for the camera kinematics model.
    type Spec;

    /// Construct the kinematics for a camera from its specification.
    fn from_spec(spec: &Self::Spec) -> Self;
    
    /// Compute the change in the position and orientation of the camera 
    /// based on the input camera movement.
    fn update(&self, movement: CameraMovement, elapsed: S) -> DeltaAttitude<S>;
}


/// A perspective projection based on the `near` plane, the `far` plane and 
/// the vertical field of view angle `fovy` and the horizontal/vertical aspect 
/// ratio `aspect`.
///
/// We assume the following constraints to make a useful perspective projection 
/// transformation.
/// ```text
/// 0 radians < fovy < pi radians
/// aspect > 0
/// near < far (along the negative z-axis)
/// ```
/// This perspective projection model imposes some constraints on the more 
/// general perspective specification based on the arbitrary planes. The `fovy` 
/// parameter combined with the aspect ratio `aspect` ensures that the top and 
/// bottom planes are the same distance from the eye position along the vertical 
/// axis on opposite side. They ensure that the `left` and `right` planes are 
/// equidistant from the eye on opposite sides along the horizontal axis. 
#[repr(C)]
#[derive(Clone, Debug)]
pub struct PerspectiveFovSpec<S> {
    /// The vertical field of view angle of the perspective transformation
    /// viewport.
    fovy: Degrees<S>,
    /// The ratio of the horizontal width to the vertical height.
    aspect: S,
    /// The position of the near plane along the **negative z-axis**.
    near: S,
    /// The position of the far plane along the **negative z-axis**.
    far: S,
}

impl<S> PerspectiveFovSpec<S> {
    /// Construct a new perspective projection operation specification
    /// based on the vertical field of view angle `fovy`, the `near` plane, the 
    /// `far` plane, and aspect ratio `aspect`.
    pub fn new(fovy: Degrees<S>, aspect: S, near: S, far: S) -> PerspectiveFovSpec<S> {
        PerspectiveFovSpec {
            fovy: fovy,
            aspect: aspect,
            near: near,
            far: far,
        }
    }
}

impl<S> fmt::Display for PerspectiveFovSpec<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
       write!(
           formatter,
           "PerspectiveFovSpec [fovy={}, aspect={}, near={}, far={}]",
           self.fovy, self.aspect, self.near, self.far
       )
    }
}


/// A perspective projection transformation for converting from camera space to
/// normalized device coordinates based on the perspective field of view model.
///
/// Orthographic projections differ from perspective projections because
/// orthographic projections keeps parallel lines parallel, whereas perspective 
/// projections preserve the perception of distance. Perspective 
/// projections preserve the spatial ordering of points in the distance they 
/// are located from the viewing plane. This property of perspective projection 
/// transformations is important for operations such as z-buffering and 
/// occlusion detection.
#[repr(C)]
#[derive(Clone, Debug)]
pub struct PerspectiveFovProjection<S> {
    /// The vertical field of view angle of the perspective transformation
    /// viewport.
    fovy: Degrees<S>,
    /// The ratio of the horizontal width to the vertical height.
    aspect: S,
    /// The position of the near plane along the **negative z-axis**.
    near: S,
    /// The position of the far plane along the **negative z-axis**.
    far: S,
    /// The underlying perspective projection transformation.
    matrix: Matrix4x4<S>,
}

impl<S> PerspectiveFovProjection<S> {
    /// Returns a reference to the underlying perspective projection matrix.
    #[inline]
    pub fn to_matrix(&self) -> &Matrix4x4<S> {
        &self.matrix
    }
}

impl<S> fmt::Display for PerspectiveFovProjection<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "PerspectiveFovProjection [{}]",
            self.matrix
        )
    }    
}

impl<S> CameraModel for PerspectiveFovProjection<S> where S: ScalarFloat {
    type Spec = PerspectiveFovSpec<S>;
    type Projection = Matrix4x4<S>;

    #[inline]
    fn from_spec(spec: &Self::Spec) -> Self {
        let matrix = Matrix4x4::from_perspective_fov(
            spec.fovy, 
            spec.aspect, 
            spec.near, 
            spec.far
        );

        PerspectiveFovProjection {
            fovy: spec.fovy,
            aspect: spec.aspect,
            near: spec.near,
            far: spec.far,
            matrix: matrix,
        }
    }

    #[inline]
    fn projection(&self) -> &Self::Projection {
        &self.matrix
    }

    fn update(&mut self, width: usize, height: usize) {
        let width_float = cglinalg::num_traits::cast::<usize, S>(width).unwrap();
        let height_float = cglinalg::num_traits::cast::<usize, S>(height).unwrap();
        self.aspect = width_float / height_float;
        self.matrix = Matrix4x4::from_perspective_fov(
            self.fovy, 
            self.aspect, 
            self.near, 
            self.far
        );
    }
}


/// A perspective projection based on arbitrary `left`, `right`, `bottom`,
/// `top`, `near`, and `far` planes.
///
/// We assume the following constraints to construct a useful perspective 
/// projection
/// ```text
/// left   < right
/// bottom < top
/// near   < far   (along the negative z-axis)
/// ```
/// Each parameter in the specification is a description of the position along
/// an axis of a plane that the axis is perpendicular to.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct PerspectiveSpec<S> {
    /// The horizontal position of the left-hand plane in camera space.
    /// The left-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    left: S,
    /// The horizontal position of the right-hand plane in camera space.
    /// The right-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    right: S,
    /// The vertical position of the bottom plane in camera space.
    /// The bottom plane is a plane parallel to the **xz-plane** at the origin.
    bottom: S,
    /// The vertical position of the top plane in camera space.
    /// the top plane is a plane parallel to the **xz-plane** at the origin.
    top: S,
    /// The distance along the **negative z-axis** of the near plane from the eye.
    /// The near plane is a plane parallel to the **xy-plane** at the origin.
    near: S,
    /// the distance along the **negative z-axis** of the far plane from the eye.
    /// The far plane is a plane parallel to the **xy-plane** at the origin.
    far: S,
}

impl<S> PerspectiveSpec<S> {
    /// Construct a new perspective specification.
    #[inline]
    pub const fn new(left: S, right: S, bottom: S, top: S, near: S, far: S) -> PerspectiveSpec<S> {
        PerspectiveSpec {
            left: left,
            right: right,
            bottom: bottom,
            top: top,
            near: near,
            far: far,
        }
    }
}

impl<S> fmt::Display for PerspectiveSpec<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "PerspectiveSpec [left={}, right={}, bottom={}, top={}, near={}, far={}]",
            self.left, self.right, self.bottom, self.top, self.near, self.far
        )
    }
}


/// A perspective projection transformation for converting from camera space to
/// normalized device coordinates.
///
/// Orthographic projections differ from perspective projections because
/// orthographic projections keeps parallel lines parallel, whereas perspective 
/// projections preserve the perception of distance. Perspective 
/// projections preserve the spatial ordering of points in the distance they 
/// are located from the viewing plane. This property of perspective projection 
/// transformations is important for operations such as z-buffering and 
/// occlusion detection.
#[repr(C)]
#[derive(Clone, Debug)]
pub struct PerspectiveProjection<S> {
    /// The horizontal position of the left-hand plane in camera space.
    /// The left-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    left: S,
    /// The horizontal position of the right-hand plane in camera space.
    /// The right-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    right: S,
    /// The vertical position of the bottom plane in camera space.
    /// The bottom plane is a plane parallel to the **xz-plane** at the origin.
    bottom: S,
    /// The vertical position of the top plane in camera space.
    /// the top plane is a plane parallel to the **xz-plane** at the origin.
    top: S,
    /// The distance along the **negative z-axis** of the near plane from the eye.
    /// The near plane is a plane parallel to the **xy-plane** at the origin.
    near: S,
    /// the distance along the **negative z-axis** of the far plane from the eye.
    /// The far plane is a plane parallel to the **xy-plane** at the origin.
    far: S,
    /// The underlying perspective projection matrix.
    matrix: Matrix4x4<S>
}

impl<S> PerspectiveProjection<S> {
    /// Returns a reference to the underlying perspective projection matrix.
    #[inline]
    pub fn to_matrix(&self) -> &Matrix4x4<S> {
        &self.matrix
    }
}

impl<S> fmt::Display for PerspectiveProjection<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "PerspectiveProjection [{}]",
            self.matrix
        )
    }
}

impl<S> CameraModel for PerspectiveProjection<S> where S: ScalarFloat {
    type Spec = PerspectiveSpec<S>;
    type Projection = Matrix4x4<S>;

    #[inline]
    fn from_spec(spec: &Self::Spec) -> Self {
        let matrix = Matrix4x4::from_perspective(
            spec.left, 
            spec.right, 
            spec.bottom, 
            spec.top,
            spec.near,
            spec.far
        );

        PerspectiveProjection {
            left: spec.left,
            right: spec.right,
            bottom: spec.bottom,
            top: spec.top,
            near: spec.near,
            far: spec.far,
            matrix: matrix,
        }
    }

    #[inline]
    fn projection(&self) -> &Self::Projection {
        &self.matrix
    }

    fn update(&mut self, _width: usize, _height: usize) {
        // let width_float = cglinalg::num_traits::cast::<usize, S>(width).unwrap();
        // let height_float = cglinalg::num_traits::cast::<usize, S>(height).unwrap();
    }
}


/// A description of an orthographic projection with arbitrary `left`, `right`, 
/// `top`, `bottom`, `near`, and `far` planes.
///
/// We assume the following constraints to construct a useful orthographic 
/// projection
/// ```text
/// left   < right
/// bottom < top
/// near   < far   (along the negative z-axis).
/// ```
/// Each parameter in the specification is a description of the position along 
/// an axis of a plane that the axis is perpendicular to.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct OrthographicSpec<S> {
    /// The horizontal position of the left-hand plane in camera space.
    /// The left-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    left: S,
    /// The horizontal position of the right-hand plane in camera space.
    /// The right-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    right: S,
    /// The vertical position of the **bottom plane** in camera space.
    /// The bottom plane is a plane parallel to the **xz-plane** at the origin.
    bottom: S,
    /// The vertical position of the **top plane** in camera space.
    /// the top plane is a plane parallel to the **xz-plane** at the origin.
    top: S,
    /// The distance along the **negative z-axis** of the **near plane** from the eye.
    /// The near plane is a plane parallel to the **xy-plane** at the origin.
    near: S,
    /// the distance along the **negative z-axis** of the **far plane** from the eye.
    /// The far plane is a plane parallel to the **xy-plane** at the origin.
    far: S,
}

impl<S> OrthographicSpec<S> {
    /// Construct a new orthographic specification.
    #[inline]
    pub const fn new(left: S, right: S, bottom: S, top: S, near: S, far: S) -> OrthographicSpec<S> {
        OrthographicSpec {
            left: left,
            right: right,
            bottom: bottom,
            top: top,
            near: near,
            far: far,
        }
    }
}

impl<S> fmt::Display for OrthographicSpec<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "OrthographicSpec [left={}, right={}, bottom={}, top={}, near={}, far={}]",
            self.left, self.right, self.bottom, self.top, self.near, self.far
        )
    }
}


/// An orthographic projection transformation for converting from camera space to
/// normalized device coordinates. 
///
/// Orthographic projections differ from perspective projections in that 
/// orthographic projections keeps parallel lines parallel, whereas perspective 
/// projections preserve the perception of distance. Perspective 
/// projections preserve the spatial ordering in the distance that points are 
/// located from the viewing plane.
#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct OrthographicProjection<S> {
    /// The horizontal position of the left-hand plane in camera space.
    /// The left-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    left: S,
    /// The horizontal position of the right-hand plane in camera space.
    /// The right-hand plane is a plane parallel to the **yz-plane** at
    /// the origin.
    right: S,
    /// The vertical position of the **bottom plane** in camera space.
    /// The bottom plane is a plane parallel to the **xz-plane** at the origin.
    bottom: S,
    /// The vertical position of the **top plane** in camera space.
    /// the top plane is a plane parallel to the **xz-plane** at the origin.
    top: S,
    /// The distance along the **negative z-axis** of the **near plane** from the eye.
    /// The near plane is a plane parallel to the **xy-plane** at the origin.
    near: S,
    /// the distance along the **negative z-axis** of the **far plane** from the eye.
    /// The far plane is a plane parallel to the **xy-plane** at the origin.
    far: S,
    /// The underlying matrix that implements the orthographic projection.
    matrix: Matrix4x4<S>,
}

impl<S> OrthographicProjection<S> where S: ScalarFloat {
    /// Get the underlying matrix implementing the orthographic transformation.
    #[inline]
    pub fn to_matrix(&self) -> &Matrix4x4<S> {
        &self.matrix
    }
}

impl<S> fmt::Display for OrthographicProjection<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "Orthographicrojection [{}]",
            self.matrix
        )
    }
}

impl<S> CameraModel for OrthographicProjection<S> where S: ScalarFloat {
    type Spec = OrthographicSpec<S>;
    type Projection = Matrix4x4<S>;

    #[inline]
    fn from_spec(spec: &Self::Spec) -> Self {
        let matrix = Matrix4x4::from_orthographic(
            spec.left, 
            spec.right, 
            spec.bottom, 
            spec.top,
            spec.near,
            spec.far
        );

        OrthographicProjection {
            left: spec.left,
            right: spec.right,
            bottom: spec.bottom,
            top: spec.top,
            near: spec.near,
            far: spec.far,
            matrix: matrix,
        }
    }

    #[inline]
    fn projection(&self) -> &Self::Projection {
        &self.matrix
    }

    fn update(&mut self, _width: usize, _height: usize) {
        // let width_float = cglinalg::num_traits::cast::<usize, S>(width).unwrap();
        // let height_float = cglinalg::num_traits::cast::<usize, S>(height).unwrap();
    }
}


/// An orthographic projection based on the `near` plane, the `far` plane and 
/// the vertical field of view angle `fovy` and the horizontal/vertical aspect 
/// ratio `aspect`.
///
/// We assume the following constraints to make a useful orthographic projection 
/// camera model.
/// ```text
/// 0 radians < fovy < pi radians
/// aspect > 0
/// near < far (along the negative z-axis)
/// ```
/// This orthographic projection model imposes some constraints on the more 
/// general orthographic specification based on the arbitrary planes. The `fovy` 
/// parameter combined with the aspect ratio `aspect` ensures that the top and 
/// bottom planes are the same distance from the eye position along the vertical 
/// axis on opposite side. They ensure that the `left` and `right` planes are 
/// equidistant from the eye on opposite sides along the horizontal axis. 
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct OrthographicFovSpec<S> {
    /// The vertical field of view angle of the orthographic camera model 
    /// viewport.
    fovy: Degrees<S>,
    /// The ratio of the horizontal width to the vertical height.
    aspect: S,
    /// The position of the near plane along the **negative z-axis**.
    near: S,
    /// The position of the far plane along the **negative z-axis**.
    far: S,
}

impl<S> OrthographicFovSpec<S> {
    /// Construct a new orthographic projection operation specification
    /// based on the vertical field of view angle `fovy`, the `near` plane, the 
    /// `far` plane, and aspect ratio `aspect`.
    #[inline]
    pub fn new(fovy: Degrees<S>, aspect: S, near: S, far: S) -> OrthographicFovSpec<S> {
        OrthographicFovSpec {
            fovy: fovy,
            aspect: aspect,
            near: near,
            far: far,
        }
    }
}

impl<S> fmt::Display for OrthographicFovSpec<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "OrthographicFovSpec [fovy={}, aspect={}, near={}, far={}]",
            self.fovy, self.aspect, self.near, self.far
        )
    }
}


/// An orthographic projection camera model for converting from camera space to
/// normalized device coordinates.
///
/// Orthographic projections differ from perspective projections in that 
/// orthographic projections keeps parallel lines parallel, whereas perspective 
/// projections preserve the perception of distance. Perspective 
/// projections preserve the spatial ordering in the distance that points are 
/// located from the viewing plane.
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct OrthographicFovProjection<S> {
    /// The vertical field of view angle of the orthographic camera model 
    /// viewport.
    fovy: Degrees<S>,
    /// The ratio of the horizontal width to the vertical height.
    aspect: S,
    /// The position of the near plane along the **negative z-axis**.
    near: S,
    /// The position of the far plane along the **negative z-axis**.
    far: S,
    /// The underlying matrix that implements the orthographic projection.
    matrix: Matrix4x4<S>,
}

impl<S> OrthographicFovProjection<S> where S: ScalarFloat {
    /// Get the underlying matrix implementing the orthographic camera model.
    #[inline]
    pub fn to_matrix(&self) -> &Matrix4x4<S> {
        &self.matrix
    }
}

impl<S> fmt::Display for OrthographicFovProjection<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "OrthographicFovProjection [{}]",
            self.matrix
        )
    }
}

impl<S> CameraModel for OrthographicFovProjection<S> where S: ScalarFloat {
    type Spec = OrthographicFovSpec<S>;
    type Projection = Matrix4x4<S>;

    #[inline]
    fn from_spec(spec: &Self::Spec) -> Self {
        let matrix = Matrix4x4::from_orthographic_fov(
            spec.fovy, 
            spec.aspect, 
            spec.near,
            spec.far
        );

        OrthographicFovProjection {
            fovy: spec.fovy,
            aspect: spec.aspect,
            near: spec.near,
            far: spec.far,
            matrix: matrix,
        }
    }

    #[inline]
    fn projection(&self) -> &Self::Projection {
        &self.matrix
    }

    fn update(&mut self, width: usize, height: usize) {
        let width_float = cglinalg::num_traits::cast::<usize, S>(width).unwrap();
        let height_float = cglinalg::num_traits::cast::<usize, S>(height).unwrap();
        self.aspect = width_float / height_float;
        self.matrix = Matrix4x4::from_orthographic_fov(
            self.fovy, 
            self.aspect, 
            self.near, 
            self.far
        );
    }
}


/// A specification describing a rigid body transformation for the attitude 
/// (position and orientation) of a camera. The spec describes the location, 
/// local coordinate system, and rotation axis for the camera in world space.
/// The coordinate transformation is right-handed orthonormal transformation.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct CameraAttitudeSpec<S> {
    /// The location of the camera eye position in world space.
    position: Vector3<S>,
    /// The direction of the **negative z-axis** (forward axis) of the camera.
    forward: Vector3<S>,
    /// The direction of the **positive x-axis** (right axis) of the camera.
    right: Vector3<S>,
    /// The direction of the **positive y-axis** (up axis) of the camera.
    up: Vector3<S>,
    /// The **axis of rotation** of the camera. It is not necessary that 
    /// the axis of rotation of the camera be the same as one of the coordinate
    /// axes.
    axis: Vector3<S>,
}

impl<S> CameraAttitudeSpec<S> where S: ScalarFloat {
    /// Construct a new camera attitude specification.
    #[inline]
    pub fn new(
        position: Vector3<S>,
        forward: Vector3<S>,
        right: Vector3<S>,
        up: Vector3<S>,
        axis: Vector3<S>) -> Self {

        CameraAttitudeSpec {
            position: position,
            forward: forward,
            right: right,
            up: up,
            axis: axis,
        }
    }
}

impl<S> fmt::Display for CameraAttitudeSpec<S> where S: fmt::Display {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(
            formatter,
            "CameraAttitudeSpec [position={}, forward={}, right={} up={}, axis={}]",
            self.position, self.forward, self.right, self.up, self.axis
        )
    }
}


/// This type contains all the data for tracking the position and orientation
/// of a camera in world space as well as for transforming vectors from world 
/// space to the camera's view space. The camera attitude here uses a 
/// right-handed coordinate system facing along the camera's **negative z-axis**.
/// The coordinate system is a right-handed coordinate system with orthonormal
/// basis vectors.
#[repr(C)]
#[derive(Clone, Debug)]
struct CameraAttitude<S> {
    /// The world space position of the camera.
    position: Vector3<S>,
    /// The distance from the camera eye perpendicular
    forward: Vector4<S>,
    /// The horizontal axis of the camera's viewing plane.
    right: Vector4<S>,
    /// The vertical axis of the camera's viewing plane.
    up: Vector4<S>,
    /// The **axis of rotation** of the camera. It is not necessary that 
    /// the axis of rotation of the camera be the same as one of the coordinate
    /// axes.
    axis: Quaternion<S>,
    /// The translation matrix mapping objects from the world space coordinate
    /// frame to the coordinate frame centered at the eye position of the camera.
    translation_matrix: Matrix4x4<S>,
    /// The rotation matrix rotating the a vector in world space to the coordinate
    /// system of the camera's view space.
    rotation_matrix: Matrix4x4<S>,
    /// The viewing matrix of the camera mapping the complete translation + rotation
    /// of the camera.
    view_matrix: Matrix4x4<S>,
}

impl<S> CameraAttitude<S> where S: ScalarFloat {
    /// Construct the camera's viewing transformation from its specification. 
    fn from_spec(spec: &CameraAttitudeSpec<S>) -> CameraAttitude<S> {
        let axis = Quaternion::from_parts(S::zero(), spec.axis);
        let translation_matrix = Matrix4x4::from_affine_translation(
            &(-spec.position)
        );
        let rotation_matrix = Matrix4x4::from(&axis);
        let view_matrix = rotation_matrix * translation_matrix;

        CameraAttitude {
            position: spec.position,
            forward: spec.forward.expand(S::zero()),
            right: spec.right.expand(S::zero()),
            up: spec.up.expand(S::zero()),
            axis: axis,
            translation_matrix: translation_matrix,
            rotation_matrix: rotation_matrix,
            view_matrix: view_matrix,
        }

    }

    /// Get the camera's up direction in camera space.
    #[inline]
    fn up_axis_eye(&self) -> Vector3<S> {
        let zero = S::zero();
        let one = S::one();

        Vector3::new(zero, one, zero)
    }
        
    /// Get the camera's right axis in camera space.
    #[inline]
    fn right_axis_eye(&self) -> Vector3<S> {
        let zero = S::zero();
        let one = S::one();
        
        Vector3::new(one, zero ,zero)
    }
        
    /// Get the camera's forward axis in camera space.
    #[inline]
    fn forward_axis_eye(&self) -> Vector3<S> {
        let zero = S::zero();
        let one = S::one();
        
        Vector3::new(zero, zero, -one)
    }

    /// Change the camera's attitude according to its kinematics model and the
    /// next camera movement input.  
    #[inline]
    fn update_movement<K: CameraKinematics<S>>(
        &mut self, kinematics: &K, movement: CameraMovement, elapsed: S) {
        
        let delta_attitude = kinematics.update(movement, elapsed);
        self.update(&delta_attitude);
    }

    /// Update the camera position based on the change in the camera's 
    /// attitude.
    #[inline]
    fn update_position(&mut self, delta_attitude: &DeltaAttitude<S>) {
        self.position += self.forward.contract() * -delta_attitude.z;
        self.position += self.up.contract()      *  delta_attitude.y;
        self.position += self.right.contract()   *  delta_attitude.x;

        let translation_inv = Matrix4x4::from_affine_translation(
            &self.position
        );
        self.translation_matrix = translation_inv.inverse().unwrap();
    }

    /// Update the camera axes so we can rotate the camera about the new rotation axes.
    #[inline]
    fn update_orientation(&mut self, delta_attitude: &DeltaAttitude<S>) {
        let axis_yaw = Unit::from_value(self.up.contract());
        let q_yaw = Quaternion::from_axis_angle(
            &axis_yaw, Degrees(delta_attitude.yaw)
        );
        self.axis = q_yaw * self.axis;

        let axis_pitch = Unit::from_value(self.right.contract());
        let q_pitch = Quaternion::from_axis_angle(
            &axis_pitch, Degrees(delta_attitude.pitch)
        );
        self.axis = q_pitch * self.axis;

        let axis_roll = Unit::from_value(self.forward.contract());
        let q_roll = Quaternion::from_axis_angle(
            &axis_roll, Degrees(delta_attitude.roll), 
        );
        self.axis = q_roll * self.axis;

        let rotation_matrix_inv = Matrix4x4::from(&self.axis);
        self.forward = rotation_matrix_inv * self.forward_axis_eye().expand(S::zero());
        self.right   = rotation_matrix_inv * self.right_axis_eye().expand(S::zero());
        self.up      = rotation_matrix_inv * self.up_axis_eye().expand(S::zero());
        self.rotation_matrix = rotation_matrix_inv.inverse().unwrap();
    }

    /// Update the camera's attitude based on the input change in camera 
    /// attitude.
    #[inline]
    fn update(&mut self, delta_attitude: &DeltaAttitude<S>) {
        self.update_orientation(delta_attitude);
        self.update_position(delta_attitude);
        self.view_matrix = self.rotation_matrix * self.translation_matrix;
    }

    /// Get the underlying viewing matrix of the camera.
    #[inline]
    fn view_matrix(&self) -> &Matrix4x4<S> {
        &self.view_matrix
    }
}


/// A specification of the kinematics parameters for a freely moving camera.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct FreeKinematicsSpec<S> {
    /// The movement speed of the camera.
    movement_speed: S,
    /// The rotation speed of the camera.
    rotation_speed: S,
}

impl<S> FreeKinematicsSpec<S> where S: ScalarFloat {
    /// Construct a new specification for a camera with free kinematics.
    #[inline]
    pub fn new(movement_speed: S, rotation_speed: S) -> FreeKinematicsSpec<S> {
        FreeKinematicsSpec {
            movement_speed: movement_speed,
            rotation_speed: rotation_speed,
        }
    }
}


/// A kinematics model for a freely moving camera that moves moves at constant
/// speed and constant rotation speed in world space.
#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct FreeKinematics<S> {
    /// The movement speed of the camera.
    movement_speed: S,
    /// The rotation speed of the camera.
    rotation_speed: S,
}

impl<S> CameraKinematics<S> for FreeKinematics<S> where S: ScalarFloat {
    type Spec = FreeKinematicsSpec<S>;

    #[inline]
    fn from_spec(spec: &Self::Spec) -> Self {
        FreeKinematics {
            movement_speed: spec.movement_speed,
            rotation_speed: spec.rotation_speed,
        }
    }

    #[inline]
    fn update(&self, movement: CameraMovement, elapsed: S) -> DeltaAttitude<S> {
        let mut delta_attitude = DeltaAttitude::zero();

        if movement.total & MOVE_LEFT != 0 {
            delta_attitude.x -= self.movement_speed * elapsed;
        }
        if movement.total & MOVE_RIGHT != 0 {
            delta_attitude.x += self.movement_speed * elapsed;
        }
        if movement.total & MOVE_UP != 0 {
            delta_attitude.y -= self.movement_speed * elapsed;
        }
        if movement.total & MOVE_DOWN != 0 {
            delta_attitude.y += self.movement_speed * elapsed;
        }
        if movement.total & MOVE_FORWARD != 0 {
            // We subtract along z-axis to move forward because the
            // forward axis is the (-z) direction in camera space.
            delta_attitude.z -= self.movement_speed * elapsed;
        }
        if movement.total & MOVE_BACKWARD != 0 {
            // We add along the z-axis to move backward because the
            // forward axis is the (-z) direction in camera space.
            delta_attitude.z += self.movement_speed * elapsed;
        }

        if movement.total & PITCH_UP != 0 {
            delta_attitude.pitch += self.rotation_speed * elapsed;
        }
        if movement.total & PITCH_DOWN != 0 {
            delta_attitude.pitch -= self.rotation_speed * elapsed;
        }
        if movement.total & YAW_LEFT != 0 {
            delta_attitude.yaw += self.rotation_speed * elapsed;
        }
        if movement.total & YAW_RIGHT != 0 {
            delta_attitude.yaw -= self.rotation_speed * elapsed;
        }
        if movement.total & ROLL_CLOCKWISE != 0 {
            delta_attitude.roll += self.rotation_speed * elapsed;
        }
        if movement.total & ROLL_COUNTERCLOCKWISE != 0 {
            delta_attitude.roll -= self.rotation_speed * elapsed;
        }

        delta_attitude
    }
}




/// A controllable camera that maps light rays from a scene to pixels 
/// in a viewport. This camera model has three components:
/// * A camera model for mapping light rays to images. This can model many kinds
///   of ranging from the usual orthographic and perspective pinhole cameras, to
///   more sophisticated camera models including effects like depth of field, etc.
/// * The camera's attitude: the attitude is the camera's orientation and position in
///   world space, modeled as a rotation and a translation.
/// * A kinematics model for the camera. The kinematics model is a description of how
///   the camera moves around the scene in response to camera movement input.
#[repr(C)]
#[derive(Clone, Debug)]
pub struct Camera<S, M, K> {
    /// The camera's model for mapping light rays to normalized device
    /// coordinates.
    model: M,
    /// The position and orientation of the camera in world space.
    attitude: CameraAttitude<S>,
    /// The kinematics model for the camera.
    kinematics: K,
}

impl<S, M, K> Camera<S, M, K> 
    where S: ScalarFloat,
          M: CameraModel,
          K: CameraKinematics<S>,
{
    /// Construct a new camera.
    pub fn new(
        model_spec: &M::Spec, 
        attitude_spec: &CameraAttitudeSpec<S>, 
        kinematics_spec: &K::Spec) -> Self {

        Camera {
            model: <M as CameraModel>::from_spec(model_spec),
            attitude: CameraAttitude::from_spec(attitude_spec),
            kinematics: <K as CameraKinematics<S>>::from_spec(kinematics_spec)
        }
    }

    /// Update the motion of the camera based on the input camera movement
    /// `movement` and the amount of time passed `elapsed`.
    pub fn update_movement(&mut self, movement: CameraMovement, elapsed: S) {
        self.attitude.update_movement(&self.kinematics, movement, elapsed);
    }

    /// Update the camera model based on changes to the viewport's dimensions.
    pub fn update_viewport(&mut self, width: usize, height: usize) {
        self.model.update(width, height);
    }

    /// Update the camera's attitude (i.e. position and orientation) in
    /// world space.
    pub fn update_attitude(&mut self, delta_attitude: &DeltaAttitude<S>) {
        self.attitude.update(delta_attitude);
    }

    /// Get the camera's position in world space.
    #[inline]
    pub fn position(&self) -> Vector3<S> { 
        self.attitude.position
    }
    
    /// Get the camera's up direction in world space.
    #[inline]
    pub fn up_axis(&self) -> Vector3<S> {
        self.attitude.up.contract()
    }
    
    /// Get the camera's right axis in world space.
    #[inline]
    pub fn right_axis(&self) -> Vector3<S> {
        self.attitude.right.contract()
    }
    
    /// Get the camera's forward axis in world space.
    #[inline]
    pub fn forward_axis(&self) -> Vector3<S> {
        self.attitude.forward.contract()
    }
    
    /// Get the camera's **vertical y-axis** in camera view space.
    #[inline]
    pub fn up_axis_eye(&self) -> Vector3<S> {
        self.attitude.up_axis_eye()
    }
        
    /// Get the camera's **horizontal x-axis** in camera view space.
    #[inline]
    pub fn right_axis_eye(&self) -> Vector3<S> {
        self.attitude.right_axis_eye()
    }
        
    /// Get the camera's **forward z-axis** in camera view space.
    #[inline]
    pub fn forward_axis_eye(&self) -> Vector3<S> {
        self.attitude.forward_axis_eye()
    }
    
    /// Get the camera's axis of rotation.
    #[inline]
    pub fn rotation_axis(&self) -> Vector3<S> {
        self.attitude.axis.v
    }

    /// Get the camera's viewing matrix.
    #[inline]
    pub fn view_matrix(&self) -> &Matrix4x4<S> {
        self.attitude.view_matrix()
    }

    /// Return the underlying projection the camera uses to transform from
    /// view space to the camera's canonical view volume.
    #[inline]
    pub fn projection(&self) -> &M::Projection {
        self.model.projection()
    }
}

